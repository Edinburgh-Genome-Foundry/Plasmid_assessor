{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Plasmid assessor Plasmid assessment for Golden Gate cloning. An important task in DNA assembly is creating or adapting a plasmid to serve as a backbone for the assembled parts. This package provides tools for quickly checking a few basic backbone requirements on a plasmid sequence. The most important steps of vector (backbone) adaptation are ensuring that there are: two sites for the chosen restriction enzyme, flanking the insert segment no other sites for the restriction enzyme The choice of the two backbone overhangs are also important, because they will be involved in all assemblies using that plasmid. Additionally, we can add selection for proper assembly (for example, by including a ccdB suicide cassette at the insertion location) and for presence of plasmid in the bacterium (for example, by using antibiotic resistance). Finally, we can check that the replicon and the partitioning system in the plasmid suits the strain, compatibility and other requirements. Install pip install plasmid_assessor # pip install plasmid_assessor [ report ] # install with dependencies for pdf reports Usage import plasmid_assessor as plasma # Load your Genbank or FASTA file as a Biopython SeqRecord, or create a new one: from Bio.SeqRecord import SeqRecord from Bio.Seq import Seq sequence = SeqRecord ( Seq ( \"CGTCTCAACTG\" + \"AAA\" + \"TATCAGAGACG\" + \"AGGTCTC\" ), annotations = { \"topology\" : \"circular\" }) # Evaluate plasmid: design = plasma . Assessment ( sequence , \"BsmBI\" ) design . assess_plasmid ( other_enzymes = [ \"BsaI\" ]) # also check for the enzyme of the 2nd level assembly # Results are stored in: design . results # Save as a PDF report: plasma . write_pdf_report ( \"report.pdf\" , design ) Versioning Plasmid assessor uses the semantic versioning scheme. License = MIT Plasmid assessor is free/libre and open-source software, which means the users have the freedom to run, study, change and distribute the software. Plasmid assessor was written at the Edinburgh Genome Foundry by Peter Vegh . Copyright 2021 Edinburgh Genome Foundry, University of Edinburgh","title":"Home"},{"location":"#plasmid-assessor","text":"Plasmid assessment for Golden Gate cloning. An important task in DNA assembly is creating or adapting a plasmid to serve as a backbone for the assembled parts. This package provides tools for quickly checking a few basic backbone requirements on a plasmid sequence. The most important steps of vector (backbone) adaptation are ensuring that there are: two sites for the chosen restriction enzyme, flanking the insert segment no other sites for the restriction enzyme The choice of the two backbone overhangs are also important, because they will be involved in all assemblies using that plasmid. Additionally, we can add selection for proper assembly (for example, by including a ccdB suicide cassette at the insertion location) and for presence of plasmid in the bacterium (for example, by using antibiotic resistance). Finally, we can check that the replicon and the partitioning system in the plasmid suits the strain, compatibility and other requirements.","title":"Plasmid assessor"},{"location":"#install","text":"pip install plasmid_assessor # pip install plasmid_assessor [ report ] # install with dependencies for pdf reports","title":"Install"},{"location":"#usage","text":"import plasmid_assessor as plasma # Load your Genbank or FASTA file as a Biopython SeqRecord, or create a new one: from Bio.SeqRecord import SeqRecord from Bio.Seq import Seq sequence = SeqRecord ( Seq ( \"CGTCTCAACTG\" + \"AAA\" + \"TATCAGAGACG\" + \"AGGTCTC\" ), annotations = { \"topology\" : \"circular\" }) # Evaluate plasmid: design = plasma . Assessment ( sequence , \"BsmBI\" ) design . assess_plasmid ( other_enzymes = [ \"BsaI\" ]) # also check for the enzyme of the 2nd level assembly # Results are stored in: design . results # Save as a PDF report: plasma . write_pdf_report ( \"report.pdf\" , design )","title":"Usage"},{"location":"#versioning","text":"Plasmid assessor uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-mit","text":"Plasmid assessor is free/libre and open-source software, which means the users have the freedom to run, study, change and distribute the software. Plasmid assessor was written at the Edinburgh Genome Foundry by Peter Vegh . Copyright 2021 Edinburgh Genome Foundry, University of Edinburgh","title":"License = MIT"},{"location":"reference/plasmid_assessor/","text":"Module plasmid_assessor View Source from .Assessment import Assessment from .reports import write_pdf_report Sub-modules plasmid_assessor.Assessment plasmid_assessor.reports plasmid_assessor.version","title":"Index"},{"location":"reference/plasmid_assessor/#module-plasmid_assessor","text":"View Source from .Assessment import Assessment from .reports import write_pdf_report","title":"Module plasmid_assessor"},{"location":"reference/plasmid_assessor/#sub-modules","text":"plasmid_assessor.Assessment plasmid_assessor.reports plasmid_assessor.version","title":"Sub-modules"},{"location":"reference/plasmid_assessor/Assessment/","text":"Module plasmid_assessor.Assessment View Source import re import Bio import Bio.Restriction import dnacauldron as dc class Assessment : \"\"\"The plasmid assessment class. **Parameters** **record** > A Biopython `SeqRecord`. **enzyme** > A restriction enzyme (`str`). A Biopython `RestrictionType` will be looked up using the string. \"\"\" def __init__ ( self , record , enzyme ): self . record = record self . enzyme = Bio . Restriction . __dict__ [ enzyme ] self . results = {} def assess_plasmid ( self , other_enzymes = None ): \"\"\"Evaluate plasmid for Golden Gate. **Parameters** **other_enzymes** > List of enzymes used in higher level assemblies (`list`). \"\"\" self . check_circularity () self . get_number_of_sites () self . evaluate_orientation () self . digest_plasmid () self . count_other_sites ( other_enzymes ) self . sum_results () def check_circularity ( self ): if \"topology\" not in self . record . annotations : self . results [ \"is_circular\" ] = False elif self . record . annotations [ \"topology\" ] == \"circular\" : self . results [ \"is_circular\" ] = True else : self . results [ \"is_circular\" ] = False def get_number_of_sites ( self ): if \"is_circular\" in self . results : is_linear = not self . results [ \"is_circular\" ] else : is_linear = False restriction_batch = Bio . Restriction . RestrictionBatch ([ self . enzyme ]) analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = is_linear ) analysis_results = analysis . full ( linear = is_linear ) self . results [ \"number_of_sites\" ] = len ( analysis_results [ self . enzyme ]) def evaluate_orientation ( self ): self . results [ \"is_site_orientation_correct\" ] = False # default # Forward strand: iter = ( match for match in re . finditer ( self . enzyme . site , str ( self . record . seq ))) if sum ( 1 for _ in iter ) == 1 : rev_complement = str ( self . record . seq . reverse_complement ()) iter_reverse = ( m for m in re . finditer ( self . enzyme . site , rev_complement )) if sum ( 1 for _ in iter_reverse ) == 1 : # 1 site in both strands: self . results [ \"is_site_orientation_correct\" ] = True def digest_plasmid ( self ): # Obtain fragments and get the backbone's overhangs. # This method has two assumptions: # - the sequence has two, correctly oriented enzyme sites. # - the sequence is circular. # Therefore there will be exactly two fragments, with one containing both sites. self . results [ \"digest\" ] = {} if not self . results [ \"is_circular\" ]: return if not self . results [ \"is_site_orientation_correct\" ]: return record_fragments = dc . StickyEndFragment . list_from_record_digestion ( record = self . record , enzyme = self . enzyme , linear = False ) if self . enzyme . site in record_fragments [ 0 ] . to_standard_string (): backbone_index = 1 # there are only two fragments excise_index = 0 else : backbone_index = 0 excise_index = 1 # reversed self . results [ \"digest\" ][ \"backbone_seq\" ] = record_fragments [ backbone_index ] self . results [ \"digest\" ][ \"excised_seq\" ] = record_fragments [ excise_index ] self . results [ \"digest\" ][ \"first_overhang\" ] = str ( record_fragments [ excise_index ] . seq . left_end ) self . results [ \"digest\" ][ \"last_overhang\" ] = str ( record_fragments [ excise_index ] . seq . right_end ) def count_other_sites ( self , other_enzymes ): self . results [ \"other_sites\" ] = {} if other_enzymes is None : return bio_enzymes = [ Bio . Restriction . __dict__ [ enzyme ] for enzyme in other_enzymes ] restriction_batch = Bio . Restriction . RestrictionBatch ( bio_enzymes ) # Work with the assumption that the sequence is circular: analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = False ) self . results [ \"other_sites\" ][ \"enzyme\" ] = analysis . full ( linear = False ) self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = False for enzyme , matches in self . results [ \"other_sites\" ][ \"enzyme\" ] . items (): if len ( matches ) != 0 : self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = True def sum_results ( self ): self . results [ \"pass\" ] = True if self . results [ \"is_circular\" ] is False : self . results [ \"pass\" ] = False return if self . results [ \"is_site_orientation_correct\" ] is False : # implicitly checks number of sites too self . results [ \"pass\" ] = False return if self . results [ \"other_sites\" ][ \"has_any_other_sites\" ]: self . results [ \"pass\" ] = False return Classes Assessment class Assessment ( record , enzyme ) The plasmid assessment class. Parameters record A Biopython SeqRecord . enzyme A restriction enzyme ( str ). A Biopython RestrictionType will be looked up using the string. View Source class Assessment : \"\"\"The plasmid assessment class. **Parameters** **record** > A Biopython `SeqRecord`. **enzyme** > A restriction enzyme (`str`). A Biopython `RestrictionType` will be looked up using the string. \"\"\" def __init__ ( self , record , enzyme ) : self . record = record self . enzyme = Bio . Restriction . __dict__ [ enzyme ] self . results = {} def assess_plasmid ( self , other_enzymes = None ) : \"\"\"Evaluate plasmid for Golden Gate. **Parameters** **other_enzymes** > List of enzymes used in higher level assemblies (`list`). \"\"\" self . check_circularity () self . get_number_of_sites () self . evaluate_orientation () self . digest_plasmid () self . count_other_sites ( other_enzymes ) self . sum_results () def check_circularity ( self ) : if \"topology\" not in self . record . annotations : self . results [ \"is_circular\" ] = False elif self . record . annotations [ \"topology\" ] == \"circular\" : self . results [ \"is_circular\" ] = True else : self . results [ \"is_circular\" ] = False def get_number_of_sites ( self ) : if \"is_circular\" in self . results : is_linear = not self . results [ \"is_circular\" ] else : is_linear = False restriction_batch = Bio . Restriction . RestrictionBatch ( [ self.enzyme ] ) analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = is_linear ) analysis_results = analysis . full ( linear = is_linear ) self . results [ \"number_of_sites\" ] = len ( analysis_results [ self.enzyme ] ) def evaluate_orientation ( self ) : self . results [ \"is_site_orientation_correct\" ] = False # default # Forward strand : iter = ( match for match in re . finditer ( self . enzyme . site , str ( self . record . seq ))) if sum ( 1 for _ in iter ) == 1 : rev_complement = str ( self . record . seq . reverse_complement ()) iter_reverse = ( m for m in re . finditer ( self . enzyme . site , rev_complement )) if sum ( 1 for _ in iter_reverse ) == 1 : # 1 site in both strands : self . results [ \"is_site_orientation_correct\" ] = True def digest_plasmid ( self ) : # Obtain fragments and get the backbone ' s overhangs . # This method has two assumptions : # - the sequence has two , correctly oriented enzyme sites . # - the sequence is circular . # Therefore there will be exactly two fragments , with one containing both sites . self . results [ \"digest\" ] = {} if not self . results [ \"is_circular\" ] : return if not self . results [ \"is_site_orientation_correct\" ] : return record_fragments = dc . StickyEndFragment . list_from_record_digestion ( record = self . record , enzyme = self . enzyme , linear = False ) if self . enzyme . site in record_fragments [ 0 ] . to_standard_string () : backbone_index = 1 # there are only two fragments excise_index = 0 else : backbone_index = 0 excise_index = 1 # reversed self . results [ \"digest\" ][ \"backbone_seq\" ] = record_fragments [ backbone_index ] self . results [ \"digest\" ][ \"excised_seq\" ] = record_fragments [ excise_index ] self . results [ \"digest\" ][ \"first_overhang\" ] = str ( record_fragments [ excise_index ] . seq . left_end ) self . results [ \"digest\" ][ \"last_overhang\" ] = str ( record_fragments [ excise_index ] . seq . right_end ) def count_other_sites ( self , other_enzymes ) : self . results [ \"other_sites\" ] = {} if other_enzymes is None : return bio_enzymes = [ Bio.Restriction.__dict__[enzyme ] for enzyme in other_enzymes ] restriction_batch = Bio . Restriction . RestrictionBatch ( bio_enzymes ) # Work with the assumption that the sequence is circular : analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = False ) self . results [ \"other_sites\" ][ \"enzyme\" ] = analysis . full ( linear = False ) self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = False for enzyme , matches in self . results [ \"other_sites\" ][ \"enzyme\" ] . items () : if len ( matches ) != 0 : self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = True def sum_results ( self ) : self . results [ \"pass\" ] = True if self . results [ \"is_circular\" ] is False : self . results [ \"pass\" ] = False return if self . results [ \"is_site_orientation_correct\" ] is False : # implicitly checks number of sites too self . results [ \"pass\" ] = False return if self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] : self . results [ \"pass\" ] = False return Methods assess_plasmid def assess_plasmid ( self , other_enzymes = None ) Evaluate plasmid for Golden Gate. Parameters other_enzymes List of enzymes used in higher level assemblies ( list ). View Source def assess_plasmid ( self , other_enzymes = None ) : \" \"\" Evaluate plasmid for Golden Gate. **Parameters** **other_enzymes** > List of enzymes used in higher level assemblies (`list`). \"\" \" self . check_circularity () self . get_number_of_sites () self . evaluate_orientation () self . digest_plasmid () self . count_other_sites ( other_enzymes ) self . sum_results () check_circularity def check_circularity ( self ) View Source def check_circularity ( self ) : if \" topology \" not in self . record . annotations : self . results [ \" is_circular \" ] = False elif self . record . annotations [ \" topology \" ] == \" circular \" : self . results [ \" is_circular \" ] = True else : self . results [ \" is_circular \" ] = False count_other_sites def count_other_sites ( self , other_enzymes ) View Source def count_other_sites ( self , other_enzymes ) : self . results [ \"other_sites\" ] = {} if other_enzymes is None : return bio_enzymes = [ Bio.Restriction.__dict__[enzyme ] for enzyme in other_enzymes ] restriction_batch = Bio . Restriction . RestrictionBatch ( bio_enzymes ) # Work with the assumption that the sequence is circular : analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = False ) self . results [ \"other_sites\" ][ \"enzyme\" ] = analysis . full ( linear = False ) self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = False for enzyme , matches in self . results [ \"other_sites\" ][ \"enzyme\" ] . items () : if len ( matches ) != 0 : self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = True digest_plasmid def digest_plasmid ( self ) View Source def digest_plasmid ( self ) : # Obtain fragments and get the backbone ' s overhangs . # This method has two assumptions : # - the sequence has two , correctly oriented enzyme sites . # - the sequence is circular . # Therefore there will be exactly two fragments , with one containing both sites . self . results [ \"digest\" ] = {} if not self . results [ \"is_circular\" ] : return if not self . results [ \"is_site_orientation_correct\" ] : return record_fragments = dc . StickyEndFragment . list_from_record_digestion ( record = self . record , enzyme = self . enzyme , linear = False ) if self . enzyme . site in record_fragments [ 0 ] . to_standard_string () : backbone_index = 1 # there are only two fragments excise_index = 0 else : backbone_index = 0 excise_index = 1 # reversed self . results [ \"digest\" ][ \"backbone_seq\" ] = record_fragments [ backbone_index ] self . results [ \"digest\" ][ \"excised_seq\" ] = record_fragments [ excise_index ] self . results [ \"digest\" ][ \"first_overhang\" ] = str ( record_fragments [ excise_index ] . seq . left_end ) self . results [ \"digest\" ][ \"last_overhang\" ] = str ( record_fragments [ excise_index ] . seq . right_end ) evaluate_orientation def evaluate_orientation ( self ) View Source def evaluate_orientation ( self ) : self . results [ \" is_site_orientation_correct \" ] = False # default # Forward strand : iter = ( match for match in re . finditer ( self . enzyme . site , str ( self . record . seq ))) if sum ( 1 for _ in iter ) == 1 : rev_complement = str ( self . record . seq . reverse_complement ()) iter_reverse = ( m for m in re . finditer ( self . enzyme . site , rev_complement )) if sum ( 1 for _ in iter_reverse ) == 1 : # 1 site in both strands : self . results [ \" is_site_orientation_correct \" ] = True get_number_of_sites def get_number_of_sites ( self ) View Source def get_number_of_sites ( self ) : if \" is_circular \" in self . results : is_linear = not self . results [ \" is_circular \" ] else : is_linear = False restriction_batch = Bio . Restriction . RestrictionBatch ( [ self . enzyme ] ) analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = is_linear ) analysis_results = analysis . full ( linear = is_linear ) self . results [ \" number_of_sites \" ] = len ( analysis_results [ self . enzyme ] ) sum_results def sum_results ( self ) View Source def sum_results ( self ) : self . results [ \" pass \" ] = True if self . results [ \" is_circular \" ] is False : self . results [ \" pass \" ] = False return if self . results [ \" is_site_orientation_correct \" ] is False : # implicitly checks number of sites too self . results [ \" pass \" ] = False return if self . results [ \" other_sites \" ][ \" has_any_other_sites \" ]: self . results [ \" pass \" ] = False return","title":"Assessment"},{"location":"reference/plasmid_assessor/Assessment/#module-plasmid_assessorassessment","text":"View Source import re import Bio import Bio.Restriction import dnacauldron as dc class Assessment : \"\"\"The plasmid assessment class. **Parameters** **record** > A Biopython `SeqRecord`. **enzyme** > A restriction enzyme (`str`). A Biopython `RestrictionType` will be looked up using the string. \"\"\" def __init__ ( self , record , enzyme ): self . record = record self . enzyme = Bio . Restriction . __dict__ [ enzyme ] self . results = {} def assess_plasmid ( self , other_enzymes = None ): \"\"\"Evaluate plasmid for Golden Gate. **Parameters** **other_enzymes** > List of enzymes used in higher level assemblies (`list`). \"\"\" self . check_circularity () self . get_number_of_sites () self . evaluate_orientation () self . digest_plasmid () self . count_other_sites ( other_enzymes ) self . sum_results () def check_circularity ( self ): if \"topology\" not in self . record . annotations : self . results [ \"is_circular\" ] = False elif self . record . annotations [ \"topology\" ] == \"circular\" : self . results [ \"is_circular\" ] = True else : self . results [ \"is_circular\" ] = False def get_number_of_sites ( self ): if \"is_circular\" in self . results : is_linear = not self . results [ \"is_circular\" ] else : is_linear = False restriction_batch = Bio . Restriction . RestrictionBatch ([ self . enzyme ]) analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = is_linear ) analysis_results = analysis . full ( linear = is_linear ) self . results [ \"number_of_sites\" ] = len ( analysis_results [ self . enzyme ]) def evaluate_orientation ( self ): self . results [ \"is_site_orientation_correct\" ] = False # default # Forward strand: iter = ( match for match in re . finditer ( self . enzyme . site , str ( self . record . seq ))) if sum ( 1 for _ in iter ) == 1 : rev_complement = str ( self . record . seq . reverse_complement ()) iter_reverse = ( m for m in re . finditer ( self . enzyme . site , rev_complement )) if sum ( 1 for _ in iter_reverse ) == 1 : # 1 site in both strands: self . results [ \"is_site_orientation_correct\" ] = True def digest_plasmid ( self ): # Obtain fragments and get the backbone's overhangs. # This method has two assumptions: # - the sequence has two, correctly oriented enzyme sites. # - the sequence is circular. # Therefore there will be exactly two fragments, with one containing both sites. self . results [ \"digest\" ] = {} if not self . results [ \"is_circular\" ]: return if not self . results [ \"is_site_orientation_correct\" ]: return record_fragments = dc . StickyEndFragment . list_from_record_digestion ( record = self . record , enzyme = self . enzyme , linear = False ) if self . enzyme . site in record_fragments [ 0 ] . to_standard_string (): backbone_index = 1 # there are only two fragments excise_index = 0 else : backbone_index = 0 excise_index = 1 # reversed self . results [ \"digest\" ][ \"backbone_seq\" ] = record_fragments [ backbone_index ] self . results [ \"digest\" ][ \"excised_seq\" ] = record_fragments [ excise_index ] self . results [ \"digest\" ][ \"first_overhang\" ] = str ( record_fragments [ excise_index ] . seq . left_end ) self . results [ \"digest\" ][ \"last_overhang\" ] = str ( record_fragments [ excise_index ] . seq . right_end ) def count_other_sites ( self , other_enzymes ): self . results [ \"other_sites\" ] = {} if other_enzymes is None : return bio_enzymes = [ Bio . Restriction . __dict__ [ enzyme ] for enzyme in other_enzymes ] restriction_batch = Bio . Restriction . RestrictionBatch ( bio_enzymes ) # Work with the assumption that the sequence is circular: analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = False ) self . results [ \"other_sites\" ][ \"enzyme\" ] = analysis . full ( linear = False ) self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = False for enzyme , matches in self . results [ \"other_sites\" ][ \"enzyme\" ] . items (): if len ( matches ) != 0 : self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = True def sum_results ( self ): self . results [ \"pass\" ] = True if self . results [ \"is_circular\" ] is False : self . results [ \"pass\" ] = False return if self . results [ \"is_site_orientation_correct\" ] is False : # implicitly checks number of sites too self . results [ \"pass\" ] = False return if self . results [ \"other_sites\" ][ \"has_any_other_sites\" ]: self . results [ \"pass\" ] = False return","title":"Module plasmid_assessor.Assessment"},{"location":"reference/plasmid_assessor/Assessment/#classes","text":"","title":"Classes"},{"location":"reference/plasmid_assessor/Assessment/#assessment","text":"class Assessment ( record , enzyme ) The plasmid assessment class. Parameters record A Biopython SeqRecord . enzyme A restriction enzyme ( str ). A Biopython RestrictionType will be looked up using the string. View Source class Assessment : \"\"\"The plasmid assessment class. **Parameters** **record** > A Biopython `SeqRecord`. **enzyme** > A restriction enzyme (`str`). A Biopython `RestrictionType` will be looked up using the string. \"\"\" def __init__ ( self , record , enzyme ) : self . record = record self . enzyme = Bio . Restriction . __dict__ [ enzyme ] self . results = {} def assess_plasmid ( self , other_enzymes = None ) : \"\"\"Evaluate plasmid for Golden Gate. **Parameters** **other_enzymes** > List of enzymes used in higher level assemblies (`list`). \"\"\" self . check_circularity () self . get_number_of_sites () self . evaluate_orientation () self . digest_plasmid () self . count_other_sites ( other_enzymes ) self . sum_results () def check_circularity ( self ) : if \"topology\" not in self . record . annotations : self . results [ \"is_circular\" ] = False elif self . record . annotations [ \"topology\" ] == \"circular\" : self . results [ \"is_circular\" ] = True else : self . results [ \"is_circular\" ] = False def get_number_of_sites ( self ) : if \"is_circular\" in self . results : is_linear = not self . results [ \"is_circular\" ] else : is_linear = False restriction_batch = Bio . Restriction . RestrictionBatch ( [ self.enzyme ] ) analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = is_linear ) analysis_results = analysis . full ( linear = is_linear ) self . results [ \"number_of_sites\" ] = len ( analysis_results [ self.enzyme ] ) def evaluate_orientation ( self ) : self . results [ \"is_site_orientation_correct\" ] = False # default # Forward strand : iter = ( match for match in re . finditer ( self . enzyme . site , str ( self . record . seq ))) if sum ( 1 for _ in iter ) == 1 : rev_complement = str ( self . record . seq . reverse_complement ()) iter_reverse = ( m for m in re . finditer ( self . enzyme . site , rev_complement )) if sum ( 1 for _ in iter_reverse ) == 1 : # 1 site in both strands : self . results [ \"is_site_orientation_correct\" ] = True def digest_plasmid ( self ) : # Obtain fragments and get the backbone ' s overhangs . # This method has two assumptions : # - the sequence has two , correctly oriented enzyme sites . # - the sequence is circular . # Therefore there will be exactly two fragments , with one containing both sites . self . results [ \"digest\" ] = {} if not self . results [ \"is_circular\" ] : return if not self . results [ \"is_site_orientation_correct\" ] : return record_fragments = dc . StickyEndFragment . list_from_record_digestion ( record = self . record , enzyme = self . enzyme , linear = False ) if self . enzyme . site in record_fragments [ 0 ] . to_standard_string () : backbone_index = 1 # there are only two fragments excise_index = 0 else : backbone_index = 0 excise_index = 1 # reversed self . results [ \"digest\" ][ \"backbone_seq\" ] = record_fragments [ backbone_index ] self . results [ \"digest\" ][ \"excised_seq\" ] = record_fragments [ excise_index ] self . results [ \"digest\" ][ \"first_overhang\" ] = str ( record_fragments [ excise_index ] . seq . left_end ) self . results [ \"digest\" ][ \"last_overhang\" ] = str ( record_fragments [ excise_index ] . seq . right_end ) def count_other_sites ( self , other_enzymes ) : self . results [ \"other_sites\" ] = {} if other_enzymes is None : return bio_enzymes = [ Bio.Restriction.__dict__[enzyme ] for enzyme in other_enzymes ] restriction_batch = Bio . Restriction . RestrictionBatch ( bio_enzymes ) # Work with the assumption that the sequence is circular : analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = False ) self . results [ \"other_sites\" ][ \"enzyme\" ] = analysis . full ( linear = False ) self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = False for enzyme , matches in self . results [ \"other_sites\" ][ \"enzyme\" ] . items () : if len ( matches ) != 0 : self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = True def sum_results ( self ) : self . results [ \"pass\" ] = True if self . results [ \"is_circular\" ] is False : self . results [ \"pass\" ] = False return if self . results [ \"is_site_orientation_correct\" ] is False : # implicitly checks number of sites too self . results [ \"pass\" ] = False return if self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] : self . results [ \"pass\" ] = False return","title":"Assessment"},{"location":"reference/plasmid_assessor/Assessment/#methods","text":"","title":"Methods"},{"location":"reference/plasmid_assessor/Assessment/#assess_plasmid","text":"def assess_plasmid ( self , other_enzymes = None ) Evaluate plasmid for Golden Gate. Parameters other_enzymes List of enzymes used in higher level assemblies ( list ). View Source def assess_plasmid ( self , other_enzymes = None ) : \" \"\" Evaluate plasmid for Golden Gate. **Parameters** **other_enzymes** > List of enzymes used in higher level assemblies (`list`). \"\" \" self . check_circularity () self . get_number_of_sites () self . evaluate_orientation () self . digest_plasmid () self . count_other_sites ( other_enzymes ) self . sum_results ()","title":"assess_plasmid"},{"location":"reference/plasmid_assessor/Assessment/#check_circularity","text":"def check_circularity ( self ) View Source def check_circularity ( self ) : if \" topology \" not in self . record . annotations : self . results [ \" is_circular \" ] = False elif self . record . annotations [ \" topology \" ] == \" circular \" : self . results [ \" is_circular \" ] = True else : self . results [ \" is_circular \" ] = False","title":"check_circularity"},{"location":"reference/plasmid_assessor/Assessment/#count_other_sites","text":"def count_other_sites ( self , other_enzymes ) View Source def count_other_sites ( self , other_enzymes ) : self . results [ \"other_sites\" ] = {} if other_enzymes is None : return bio_enzymes = [ Bio.Restriction.__dict__[enzyme ] for enzyme in other_enzymes ] restriction_batch = Bio . Restriction . RestrictionBatch ( bio_enzymes ) # Work with the assumption that the sequence is circular : analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = False ) self . results [ \"other_sites\" ][ \"enzyme\" ] = analysis . full ( linear = False ) self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = False for enzyme , matches in self . results [ \"other_sites\" ][ \"enzyme\" ] . items () : if len ( matches ) != 0 : self . results [ \"other_sites\" ][ \"has_any_other_sites\" ] = True","title":"count_other_sites"},{"location":"reference/plasmid_assessor/Assessment/#digest_plasmid","text":"def digest_plasmid ( self ) View Source def digest_plasmid ( self ) : # Obtain fragments and get the backbone ' s overhangs . # This method has two assumptions : # - the sequence has two , correctly oriented enzyme sites . # - the sequence is circular . # Therefore there will be exactly two fragments , with one containing both sites . self . results [ \"digest\" ] = {} if not self . results [ \"is_circular\" ] : return if not self . results [ \"is_site_orientation_correct\" ] : return record_fragments = dc . StickyEndFragment . list_from_record_digestion ( record = self . record , enzyme = self . enzyme , linear = False ) if self . enzyme . site in record_fragments [ 0 ] . to_standard_string () : backbone_index = 1 # there are only two fragments excise_index = 0 else : backbone_index = 0 excise_index = 1 # reversed self . results [ \"digest\" ][ \"backbone_seq\" ] = record_fragments [ backbone_index ] self . results [ \"digest\" ][ \"excised_seq\" ] = record_fragments [ excise_index ] self . results [ \"digest\" ][ \"first_overhang\" ] = str ( record_fragments [ excise_index ] . seq . left_end ) self . results [ \"digest\" ][ \"last_overhang\" ] = str ( record_fragments [ excise_index ] . seq . right_end )","title":"digest_plasmid"},{"location":"reference/plasmid_assessor/Assessment/#evaluate_orientation","text":"def evaluate_orientation ( self ) View Source def evaluate_orientation ( self ) : self . results [ \" is_site_orientation_correct \" ] = False # default # Forward strand : iter = ( match for match in re . finditer ( self . enzyme . site , str ( self . record . seq ))) if sum ( 1 for _ in iter ) == 1 : rev_complement = str ( self . record . seq . reverse_complement ()) iter_reverse = ( m for m in re . finditer ( self . enzyme . site , rev_complement )) if sum ( 1 for _ in iter_reverse ) == 1 : # 1 site in both strands : self . results [ \" is_site_orientation_correct \" ] = True","title":"evaluate_orientation"},{"location":"reference/plasmid_assessor/Assessment/#get_number_of_sites","text":"def get_number_of_sites ( self ) View Source def get_number_of_sites ( self ) : if \" is_circular \" in self . results : is_linear = not self . results [ \" is_circular \" ] else : is_linear = False restriction_batch = Bio . Restriction . RestrictionBatch ( [ self . enzyme ] ) analysis = Bio . Restriction . Analysis ( restriction_batch , sequence = self . record . seq , linear = is_linear ) analysis_results = analysis . full ( linear = is_linear ) self . results [ \" number_of_sites \" ] = len ( analysis_results [ self . enzyme ] )","title":"get_number_of_sites"},{"location":"reference/plasmid_assessor/Assessment/#sum_results","text":"def sum_results ( self ) View Source def sum_results ( self ) : self . results [ \" pass \" ] = True if self . results [ \" is_circular \" ] is False : self . results [ \" pass \" ] = False return if self . results [ \" is_site_orientation_correct \" ] is False : # implicitly checks number of sites too self . results [ \" pass \" ] = False return if self . results [ \" other_sites \" ][ \" has_any_other_sites \" ]: self . results [ \" pass \" ] = False return","title":"sum_results"},{"location":"reference/plasmid_assessor/reports/","text":"Module plasmid_assessor.reports View Source from datetime import datetime import os import matplotlib.pyplot as plt import pandas from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"assessment_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by EGF's Plasmid assessor (version %s )\" % ( now , __version__ ), \"plasma_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"logo.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , assessment ): \"\"\"Write an assessment report with a PDF summary. **Parameters** **target** > Path for PDF file. **assessment** > Assessment instance. \"\"\" # assessment.figure_data = pdf_tools.figure_data(assessment.fig, fmt=\"svg\") html = end_pug_to_html ( REPORT_TEMPLATE , assessment = assessment ,) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) Variables ASSETS_PATH REPORT_TEMPLATE STYLESHEET THIS_PATH Functions end_pug_to_html def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by EGF's Plasmid assessor (version %s)\" % ( now , __version__ ), \"plasma_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"logo.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) write_pdf_report def write_pdf_report ( target , assessment ) Write an assessment report with a PDF summary. Parameters target Path for PDF file. assessment Assessment instance. View Source def write_pdf_report ( target , assessment ): \"\"\"Write an assessment report with a PDF summary. **Parameters** **target** > Path for PDF file. **assessment** > Assessment instance. \"\"\" # assessment.figure_data = pdf_tools.figure_data(assessment.fig, fmt=\"svg\") html = end_pug_to_html ( REPORT_TEMPLATE , assessment = assessment ,) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Reports"},{"location":"reference/plasmid_assessor/reports/#module-plasmid_assessorreports","text":"View Source from datetime import datetime import os import matplotlib.pyplot as plt import pandas from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"assessment_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): now = datetime . now () . strftime ( \"%Y-%m- %d \" ) defaults = { \"sidebar_text\" : \"Generated on %s by EGF's Plasmid assessor (version %s )\" % ( now , __version__ ), \"plasma_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"logo.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , assessment ): \"\"\"Write an assessment report with a PDF summary. **Parameters** **target** > Path for PDF file. **assessment** > Assessment instance. \"\"\" # assessment.figure_data = pdf_tools.figure_data(assessment.fig, fmt=\"svg\") html = end_pug_to_html ( REPORT_TEMPLATE , assessment = assessment ,) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Module plasmid_assessor.reports"},{"location":"reference/plasmid_assessor/reports/#variables","text":"ASSETS_PATH REPORT_TEMPLATE STYLESHEET THIS_PATH","title":"Variables"},{"location":"reference/plasmid_assessor/reports/#functions","text":"","title":"Functions"},{"location":"reference/plasmid_assessor/reports/#end_pug_to_html","text":"def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : now = datetime . now (). strftime ( \"%Y-%m-%d\" ) defaults = { \"sidebar_text\" : \"Generated on %s by EGF's Plasmid assessor (version %s)\" % ( now , __version__ ), \"plasma_logo_url\" : os . path . join ( ASSETS_PATH , \"imgs\" , \"logo.png\" ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context )","title":"end_pug_to_html"},{"location":"reference/plasmid_assessor/reports/#write_pdf_report","text":"def write_pdf_report ( target , assessment ) Write an assessment report with a PDF summary. Parameters target Path for PDF file. assessment Assessment instance. View Source def write_pdf_report ( target , assessment ): \"\"\"Write an assessment report with a PDF summary. **Parameters** **target** > Path for PDF file. **assessment** > Assessment instance. \"\"\" # assessment.figure_data = pdf_tools.figure_data(assessment.fig, fmt=\"svg\") html = end_pug_to_html ( REPORT_TEMPLATE , assessment = assessment ,) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"write_pdf_report"},{"location":"reference/plasmid_assessor/version/","text":"Module plasmid_assessor.version View Source __version__ = \"0.1.0\"","title":"Version"},{"location":"reference/plasmid_assessor/version/#module-plasmid_assessorversion","text":"View Source __version__ = \"0.1.0\"","title":"Module plasmid_assessor.version"}]}